"""
Insights Host Inventory REST Interface

REST interface for the Insights Platform Host Inventory application.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from datetime import datetime
from typing import Annotated
from typing import Any

from pydantic import Field
from pydantic import StrictBool
from pydantic import StrictFloat
from pydantic import StrictInt
from pydantic import StrictStr
from pydantic import validate_call

from iqe_host_inventory_api_v7.api_client import ApiClient
from iqe_host_inventory_api_v7.api_client import RequestSerialized
from iqe_host_inventory_api_v7.api_response import ApiResponse
from iqe_host_inventory_api_v7.models.create_check_in import CreateCheckIn
from iqe_host_inventory_api_v7.models.host_id_out import HostIdOut
from iqe_host_inventory_api_v7.models.host_out import HostOut
from iqe_host_inventory_api_v7.models.host_query_output import HostQueryOutput
from iqe_host_inventory_api_v7.models.patch_host_in import PatchHostIn
from iqe_host_inventory_api_v7.models.system_profile_by_host_out import SystemProfileByHostOut
from iqe_host_inventory_api_v7.models.system_profile_nested_object_value import (
    SystemProfileNestedObjectValue,
)
from iqe_host_inventory_api_v7.models.tag_count_out import TagCountOut
from iqe_host_inventory_api_v7.models.tags_out import TagsOut
from iqe_host_inventory_api_v7.rest import RESTResponseType


class HostsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def api_host_delete_all_hosts(
        self,
        confirm_delete_all: Annotated[
            StrictBool | None, Field(description="Confirmation to delete all hosts on the account")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete all hosts on the account

        Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write

        :param confirm_delete_all: Confirmation to delete all hosts on the account
        :type confirm_delete_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_all_hosts_serialize(
            confirm_delete_all=confirm_delete_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_delete_all_hosts_with_http_info(
        self,
        confirm_delete_all: Annotated[
            StrictBool | None, Field(description="Confirmation to delete all hosts on the account")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete all hosts on the account

        Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write

        :param confirm_delete_all: Confirmation to delete all hosts on the account
        :type confirm_delete_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_all_hosts_serialize(
            confirm_delete_all=confirm_delete_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_delete_all_hosts_without_preload_content(
        self,
        confirm_delete_all: Annotated[
            StrictBool | None, Field(description="Confirmation to delete all hosts on the account")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete all hosts on the account

        Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write

        :param confirm_delete_all: Confirmation to delete all hosts on the account
        :type confirm_delete_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_all_hosts_serialize(
            confirm_delete_all=confirm_delete_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_delete_all_hosts_serialize(
        self,
        confirm_delete_all,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if confirm_delete_all is not None:
            _query_params.append(("confirm_delete_all", confirm_delete_all))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/hosts/all",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_delete_host_by_id(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Delete hosts by IDs

        Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_delete_host_by_id_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Delete hosts by IDs

        Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_delete_host_by_id_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete hosts by IDs

        Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_delete_host_by_id_serialize(
        self,
        host_id_list,
        branch_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/hosts/{host_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_delete_hosts_by_filter(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None, Field(description="Culling states of the hosts.")
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete the entire list of hosts filtered by the given parameters

        Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param staleness: Culling states of the hosts.
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_hosts_by_filter_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            registered_with=registered_with,
            system_type=system_type,
            staleness=staleness,
            tags=tags,
            filter=filter,
            subscription_manager_id=subscription_manager_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_delete_hosts_by_filter_with_http_info(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None, Field(description="Culling states of the hosts.")
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete the entire list of hosts filtered by the given parameters

        Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param staleness: Culling states of the hosts.
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_hosts_by_filter_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            registered_with=registered_with,
            system_type=system_type,
            staleness=staleness,
            tags=tags,
            filter=filter,
            subscription_manager_id=subscription_manager_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_delete_hosts_by_filter_without_preload_content(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None, Field(description="Culling states of the hosts.")
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete the entire list of hosts filtered by the given parameters

        Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param staleness: Culling states of the hosts.
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_delete_hosts_by_filter_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            registered_with=registered_with,
            system_type=system_type,
            staleness=staleness,
            tags=tags,
            filter=filter,
            subscription_manager_id=subscription_manager_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "202": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_delete_hosts_by_filter_serialize(
        self,
        display_name,
        fqdn,
        hostname_or_id,
        insights_id,
        provider_id,
        provider_type,
        updated_start,
        updated_end,
        last_check_in_start,
        last_check_in_end,
        group_name,
        group_id,
        registered_with,
        system_type,
        staleness,
        tags,
        filter,
        subscription_manager_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "group_name": "multi",
            "group_id": "multi",
            "registered_with": "multi",
            "system_type": "multi",
            "staleness": "multi",
            "tags": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if display_name is not None:
            _query_params.append(("display_name", display_name))

        if fqdn is not None:
            _query_params.append(("fqdn", fqdn))

        if hostname_or_id is not None:
            _query_params.append(("hostname_or_id", hostname_or_id))

        if insights_id is not None:
            _query_params.append(("insights_id", insights_id))

        if provider_id is not None:
            _query_params.append(("provider_id", provider_id))

        if provider_type is not None:
            _query_params.append(("provider_type", provider_type))

        if updated_start is not None:
            if isinstance(updated_start, datetime):
                _query_params.append((
                    "updated_start",
                    updated_start.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("updated_start", updated_start))

        if updated_end is not None:
            if isinstance(updated_end, datetime):
                _query_params.append((
                    "updated_end",
                    updated_end.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("updated_end", updated_end))

        if last_check_in_start is not None:
            if isinstance(last_check_in_start, datetime):
                _query_params.append((
                    "last_check_in_start",
                    last_check_in_start.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("last_check_in_start", last_check_in_start))

        if last_check_in_end is not None:
            if isinstance(last_check_in_end, datetime):
                _query_params.append((
                    "last_check_in_end",
                    last_check_in_end.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("last_check_in_end", last_check_in_end))

        if group_name is not None:
            _query_params.append(("group_name", group_name))

        if group_id is not None:
            _query_params.append(("group_id", group_id))

        if registered_with is not None:
            _query_params.append(("registered_with", registered_with))

        if system_type is not None:
            _query_params.append(("system_type", system_type))

        if staleness is not None:
            _query_params.append(("staleness", staleness))

        if tags is not None:
            _query_params.append(("tags", tags))

        if filter is not None:
            _query_params.append(("filter", filter))

        if subscription_manager_id is not None:
            _query_params.append(("subscription_manager_id", subscription_manager_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/hosts",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_by_id(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HostQueryOutput:
        """Find hosts by their IDs

        Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_by_id_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HostQueryOutput]:
        """Find hosts by their IDs

        Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_by_id_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find hosts by their IDs

        Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_by_id_serialize(
            host_id_list=host_id_list,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_by_id_serialize(
        self,
        host_id_list,
        branch_id,
        per_page,
        page,
        order_by,
        order_how,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        if fields is not None:
            _query_params.append(("fields", fields))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_exists(
        self,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HostIdOut:
        """Find one host by insights_id, if it exists

        Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read

        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_exists_serialize(
            insights_id=insights_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostIdOut",
            "400": None,
            "404": None,
            "409": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_exists_with_http_info(
        self,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HostIdOut]:
        """Find one host by insights_id, if it exists

        Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read

        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_exists_serialize(
            insights_id=insights_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostIdOut",
            "400": None,
            "404": None,
            "409": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_exists_without_preload_content(
        self,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find one host by insights_id, if it exists

        Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read

        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_exists_serialize(
            insights_id=insights_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostIdOut",
            "400": None,
            "404": None,
            "409": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_exists_serialize(
        self,
        insights_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if insights_id is not None:
            _query_params.append(("insights_id", insights_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/host_exists",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_list(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None,
            Field(
                description="Culling states of the hosts. Default: fresh, stale and stale_warning"
            ),
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HostQueryOutput:
        """Read the entire list of hosts

        Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param staleness: Culling states of the hosts. Default: fresh, stale and stale_warning
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_list_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            subscription_manager_id=subscription_manager_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            staleness=staleness,
            tags=tags,
            registered_with=registered_with,
            system_type=system_type,
            filter=filter,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_list_with_http_info(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None,
            Field(
                description="Culling states of the hosts. Default: fresh, stale and stale_warning"
            ),
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HostQueryOutput]:
        """Read the entire list of hosts

        Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param staleness: Culling states of the hosts. Default: fresh, stale and stale_warning
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_list_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            subscription_manager_id=subscription_manager_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            staleness=staleness,
            tags=tags,
            registered_with=registered_with,
            system_type=system_type,
            filter=filter,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_list_without_preload_content(
        self,
        display_name: Annotated[
            StrictStr | None, Field(description="Filter by display_name (case-insensitive)")
        ] = None,
        fqdn: Annotated[
            StrictStr | None, Field(description="Filter by FQDN (case-insensitive)")
        ] = None,
        hostname_or_id: Annotated[
            StrictStr | None,
            Field(description="Filter by display_name, fqdn, id (case-insensitive)"),
        ] = None,
        insights_id: Annotated[
            StrictStr | None, Field(description="Filter by insights_id")
        ] = None,
        subscription_manager_id: Annotated[
            StrictStr | None, Field(description="Filter by subscription_manager_id")
        ] = None,
        provider_id: Annotated[
            StrictStr | None, Field(description="Filter by provider_id")
        ] = None,
        provider_type: Annotated[
            StrictStr | None, Field(description="Filter by provider_type")
        ] = None,
        updated_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified after the given date"),
        ] = None,
        updated_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last modified before the given date"),
        ] = None,
        last_check_in_start: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in after the given date"),
        ] = None,
        last_check_in_end: Annotated[
            datetime | None,
            Field(description="Only show hosts last checked in before the given date"),
        ] = None,
        group_name: Annotated[
            list[StrictStr] | None, Field(description="Filter by group name")
        ] = None,
        group_id: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="Filter by group ID (UUID format)"),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        staleness: Annotated[
            list[StrictStr] | None,
            Field(
                description="Culling states of the hosts. Default: fresh, stale and stale_warning"
            ),
        ] = None,
        tags: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="filters out hosts not tagged by the given tags"),
        ] = None,
        registered_with: Annotated[
            list[StrictStr] | None,
            Field(description="Filters out any host not registered by the specified reporters"),
        ] = None,
        system_type: Annotated[
            list[StrictStr] | None, Field(description="Filters systems by type")
        ] = None,
        filter: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"workloads": {"sap": {"sap_system": {"eq": "true"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][sap_system][eq]=true" <br /><br /> To get "edge" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"host_type": {"eq": "edge"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][host_type][eq]=edge" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": {"operating_system": {"name": {"eq": "rhel"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?filter[system_profile][name][eq]=rhel"'
            ),
        ] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Read the entire list of hosts

        Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read

        :param display_name: Filter by display_name (case-insensitive)
        :type display_name: str
        :param fqdn: Filter by FQDN (case-insensitive)
        :type fqdn: str
        :param hostname_or_id: Filter by display_name, fqdn, id (case-insensitive)
        :type hostname_or_id: str
        :param insights_id: Filter by insights_id
        :type insights_id: str
        :param subscription_manager_id: Filter by subscription_manager_id
        :type subscription_manager_id: str
        :param provider_id: Filter by provider_id
        :type provider_id: str
        :param provider_type: Filter by provider_type
        :type provider_type: str
        :param updated_start: Only show hosts last modified after the given date
        :type updated_start: datetime
        :param updated_end: Only show hosts last modified before the given date
        :type updated_end: datetime
        :param last_check_in_start: Only show hosts last checked in after the given date
        :type last_check_in_start: datetime
        :param last_check_in_end: Only show hosts last checked in before the given date
        :type last_check_in_end: datetime
        :param group_name: Filter by group name
        :type group_name: List[str]
        :param group_id: Filter by group ID (UUID format)
        :type group_id: List[str]
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param staleness: Culling states of the hosts. Default: fresh, stale and stale_warning
        :type staleness: List[str]
        :param tags: filters out hosts not tagged by the given tags
        :type tags: List[str]
        :param registered_with: Filters out any host not registered by the specified reporters
        :type registered_with: List[str]
        :param system_type: Filters systems by type
        :type system_type: List[str]
        :param filter: Filters hosts based on system_profile fields. For example: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"workloads\": {\"sap\": {\"sap_system\": {\"eq\": \"true\"}}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][sap_system][eq]=true\" <br /><br /> To get \"edge\" hosts, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"host_type\": {\"eq\": \"edge\"}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][host_type][eq]=edge\" <br /><br /> To get hosts with an specific operating system, use this explicit filter: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": {\"operating_system\": {\"name\": {\"eq\": \"rhel\"}}}} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?filter[system_profile][name][eq]=rhel\"
        :type filter: Dict[str, SystemProfileNestedObjectValue]
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_list_serialize(
            display_name=display_name,
            fqdn=fqdn,
            hostname_or_id=hostname_or_id,
            insights_id=insights_id,
            subscription_manager_id=subscription_manager_id,
            provider_id=provider_id,
            provider_type=provider_type,
            updated_start=updated_start,
            updated_end=updated_end,
            last_check_in_start=last_check_in_start,
            last_check_in_end=last_check_in_end,
            group_name=group_name,
            group_id=group_id,
            branch_id=branch_id,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            staleness=staleness,
            tags=tags,
            registered_with=registered_with,
            system_type=system_type,
            filter=filter,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "HostQueryOutput",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_list_serialize(
        self,
        display_name,
        fqdn,
        hostname_or_id,
        insights_id,
        subscription_manager_id,
        provider_id,
        provider_type,
        updated_start,
        updated_end,
        last_check_in_start,
        last_check_in_end,
        group_name,
        group_id,
        branch_id,
        per_page,
        page,
        order_by,
        order_how,
        staleness,
        tags,
        registered_with,
        system_type,
        filter,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "group_name": "multi",
            "group_id": "multi",
            "staleness": "multi",
            "tags": "multi",
            "registered_with": "multi",
            "system_type": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if display_name is not None:
            _query_params.append(("display_name", display_name))

        if fqdn is not None:
            _query_params.append(("fqdn", fqdn))

        if hostname_or_id is not None:
            _query_params.append(("hostname_or_id", hostname_or_id))

        if insights_id is not None:
            _query_params.append(("insights_id", insights_id))

        if subscription_manager_id is not None:
            _query_params.append(("subscription_manager_id", subscription_manager_id))

        if provider_id is not None:
            _query_params.append(("provider_id", provider_id))

        if provider_type is not None:
            _query_params.append(("provider_type", provider_type))

        if updated_start is not None:
            if isinstance(updated_start, datetime):
                _query_params.append((
                    "updated_start",
                    updated_start.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("updated_start", updated_start))

        if updated_end is not None:
            if isinstance(updated_end, datetime):
                _query_params.append((
                    "updated_end",
                    updated_end.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("updated_end", updated_end))

        if last_check_in_start is not None:
            if isinstance(last_check_in_start, datetime):
                _query_params.append((
                    "last_check_in_start",
                    last_check_in_start.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("last_check_in_start", last_check_in_start))

        if last_check_in_end is not None:
            if isinstance(last_check_in_end, datetime):
                _query_params.append((
                    "last_check_in_end",
                    last_check_in_end.strftime(self.api_client.configuration.datetime_format),
                ))
            else:
                _query_params.append(("last_check_in_end", last_check_in_end))

        if group_name is not None:
            _query_params.append(("group_name", group_name))

        if group_id is not None:
            _query_params.append(("group_id", group_id))

        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        if staleness is not None:
            _query_params.append(("staleness", staleness))

        if tags is not None:
            _query_params.append(("tags", tags))

        if registered_with is not None:
            _query_params.append(("registered_with", registered_with))

        if system_type is not None:
            _query_params.append(("system_type", system_type))

        if filter is not None:
            _query_params.append(("filter", filter))

        if fields is not None:
            _query_params.append(("fields", fields))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_system_profile_by_id(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SystemProfileByHostOut:
        """Return one or more hosts system profile

        Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_system_profile_by_id_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            branch_id=branch_id,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemProfileByHostOut",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_system_profile_by_id_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SystemProfileByHostOut]:
        """Return one or more hosts system profile

        Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_system_profile_by_id_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            branch_id=branch_id,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemProfileByHostOut",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_system_profile_by_id_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        fields: Annotated[
            dict[str, dict[str, SystemProfileNestedObjectValue | None]] | None,
            Field(
                description='Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{"system_profile": ["arch", "host_type"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;"?fields[system_profile]=arch,host_type"'
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Return one or more hosts system profile

        Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param fields: Fetches only mentioned system_profile fields. For example, <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;{\"system_profile\": [\"arch\", \"host_type\"]} <br /><br /> which equates to the URL param: <br /><br /> &nbsp;&nbsp;&nbsp;&nbsp;\"?fields[system_profile]=arch,host_type\"
        :type fields: Dict[str, SystemProfileNestedObjectValue]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_system_profile_by_id_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            branch_id=branch_id,
            fields=fields,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemProfileByHostOut",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_system_profile_by_id_serialize(
        self,
        host_id_list,
        per_page,
        page,
        order_by,
        order_how,
        branch_id,
        fields,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        if fields is not None:
            _query_params.append(("fields", fields))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id_list}/system_profile",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_tag_count(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TagCountOut:
        """Get the number of tags on a host or hosts

        Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tag_count_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagCountOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_tag_count_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TagCountOut]:
        """Get the number of tags on a host or hosts

        Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tag_count_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagCountOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_tag_count_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the number of tags on a host or hosts

        Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tag_count_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagCountOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_tag_count_serialize(
        self,
        host_id_list,
        per_page,
        page,
        order_by,
        order_how,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id_list}/tags/count",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_get_host_tags(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        search: Annotated[
            StrictStr | None,
            Field(
                description="Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching."
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TagsOut:
        """Get the tags on a host

        Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param search: Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching.
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tags_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagsOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_get_host_tags_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        search: Annotated[
            StrictStr | None,
            Field(
                description="Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching."
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TagsOut]:
        """Get the tags on a host

        Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param search: Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching.
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tags_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagsOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_get_host_tags_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system"
            ),
        ] = None,
        search: Annotated[
            StrictStr | None,
            Field(
                description="Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching."
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the tags on a host

        Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for display_name, and to DESC for updated and operating_system
        :type order_how: str
        :param search: Used for searching tags and sap_sids that match the given search string. For searching tags, a tag's namespace, key, and/or value is used for matching.
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_get_host_tags_serialize(
            host_id_list=host_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "TagsOut",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_get_host_tags_serialize(
        self,
        host_id_list,
        per_page,
        page,
        order_by,
        order_how,
        search,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        if search is not None:
            _query_params.append(("search", search))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/hosts/{host_id_list}/tags",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_host_checkin(
        self,
        create_check_in: Annotated[
            CreateCheckIn,
            Field(description="Data required to create a check-in record for a host."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HostOut:
        """Update staleness timestamps for a host matching the provided facts

        Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write

        :param create_check_in: Data required to create a check-in record for a host. (required)
        :type create_check_in: CreateCheckIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_host_checkin_serialize(
            create_check_in=create_check_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "HostOut",
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_host_checkin_with_http_info(
        self,
        create_check_in: Annotated[
            CreateCheckIn,
            Field(description="Data required to create a check-in record for a host."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HostOut]:
        """Update staleness timestamps for a host matching the provided facts

        Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write

        :param create_check_in: Data required to create a check-in record for a host. (required)
        :type create_check_in: CreateCheckIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_host_checkin_serialize(
            create_check_in=create_check_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "HostOut",
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_host_checkin_without_preload_content(
        self,
        create_check_in: Annotated[
            CreateCheckIn,
            Field(description="Data required to create a check-in record for a host."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update staleness timestamps for a host matching the provided facts

        Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write

        :param create_check_in: Data required to create a check-in record for a host. (required)
        :type create_check_in: CreateCheckIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_host_checkin_serialize(
            create_check_in=create_check_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "HostOut",
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_host_checkin_serialize(
        self,
        create_check_in,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_check_in is not None:
            _body_params = create_check_in

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth", "BearerAuth"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/hosts/checkin",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_merge_facts(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to merge with the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Merge facts under a namespace

        Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to merge with the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_merge_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_merge_facts_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to merge with the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Merge facts under a namespace

        Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to merge with the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_merge_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_merge_facts_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to merge with the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Merge facts under a namespace

        Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to merge with the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_merge_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_merge_facts_serialize(
        self,
        host_id_list,
        namespace,
        body,
        branch_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        if namespace is not None:
            _path_params["namespace"] = namespace
        # process the query parameters
        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/hosts/{host_id_list}/facts/{namespace}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_patch_host_by_id(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        patch_host_in: Annotated[
            PatchHostIn, Field(description="A group of fields to be updated on the hosts")
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Update hosts

        Update hosts <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param patch_host_in: A group of fields to be updated on the hosts (required)
        :type patch_host_in: PatchHostIn
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_patch_host_by_id_serialize(
            host_id_list=host_id_list,
            patch_host_in=patch_host_in,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_patch_host_by_id_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        patch_host_in: Annotated[
            PatchHostIn, Field(description="A group of fields to be updated on the hosts")
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Update hosts

        Update hosts <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param patch_host_in: A group of fields to be updated on the hosts (required)
        :type patch_host_in: PatchHostIn
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_patch_host_by_id_serialize(
            host_id_list=host_id_list,
            patch_host_in=patch_host_in,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_patch_host_by_id_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        patch_host_in: Annotated[
            PatchHostIn, Field(description="A group of fields to be updated on the hosts")
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update hosts

        Update hosts <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param patch_host_in: A group of fields to be updated on the hosts (required)
        :type patch_host_in: PatchHostIn
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_patch_host_by_id_serialize(
            host_id_list=host_id_list,
            patch_host_in=patch_host_in,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "400": None,
            "404": "NotFoundErrorResponse",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_patch_host_by_id_serialize(
        self,
        host_id_list,
        patch_host_in,
        branch_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_host_in is not None:
            _body_params = patch_host_in

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/hosts/{host_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_replace_facts(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to replace the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Replace facts under a namespace

        Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to replace the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_replace_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_replace_facts_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to replace the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Replace facts under a namespace

        Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to replace the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_replace_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_replace_facts_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        namespace: Annotated[StrictStr, Field(description="A namespace of the merged facts.")],
        body: Annotated[
            dict[str, Any],
            Field(description="A dictionary with the new facts to replace the original ones."),
        ],
        branch_id: Annotated[StrictStr | None, Field(description="Filter by branch_id")] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Replace facts under a namespace

        Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param namespace: A namespace of the merged facts. (required)
        :type namespace: str
        :param body: A dictionary with the new facts to replace the original ones. (required)
        :type body: object
        :param branch_id: Filter by branch_id
        :type branch_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_replace_facts_serialize(
            host_id_list=host_id_list,
            namespace=namespace,
            body=body,
            branch_id=branch_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_replace_facts_serialize(
        self,
        host_id_list,
        namespace,
        body,
        branch_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        if namespace is not None:
            _path_params["namespace"] = namespace
        # process the query parameters
        if branch_id is not None:
            _query_params.append(("branch_id", branch_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/hosts/{host_id_list}/facts/{namespace}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
