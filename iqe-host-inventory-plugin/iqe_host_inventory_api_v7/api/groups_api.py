"""
Insights Host Inventory REST Interface

REST interface for the Insights Platform Host Inventory application.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from typing import Annotated
from typing import Any

from pydantic import Field
from pydantic import StrictFloat
from pydantic import StrictInt
from pydantic import StrictStr
from pydantic import validate_call

from iqe_host_inventory_api_v7.api_client import ApiClient
from iqe_host_inventory_api_v7.api_client import RequestSerialized
from iqe_host_inventory_api_v7.api_response import ApiResponse
from iqe_host_inventory_api_v7.models.group_in import GroupIn
from iqe_host_inventory_api_v7.models.group_out_with_host_count import GroupOutWithHostCount
from iqe_host_inventory_api_v7.models.group_query_output import GroupQueryOutput
from iqe_host_inventory_api_v7.rest import RESTResponseType


class GroupsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def api_group_create_group(
        self,
        group_in: Annotated[
            GroupIn, Field(description="Data required to create a record for a group.")
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupOutWithHostCount:
        """Create a new group matching the provided name and list of hosts IDs

        Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write

        :param group_in: Data required to create a record for a group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_create_group_serialize(
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "GroupOutWithHostCount",
            "400": None,
            "403": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_create_group_with_http_info(
        self,
        group_in: Annotated[
            GroupIn, Field(description="Data required to create a record for a group.")
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupOutWithHostCount]:
        """Create a new group matching the provided name and list of hosts IDs

        Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write

        :param group_in: Data required to create a record for a group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_create_group_serialize(
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "GroupOutWithHostCount",
            "400": None,
            "403": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_create_group_without_preload_content(
        self,
        group_in: Annotated[
            GroupIn, Field(description="Data required to create a record for a group.")
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new group matching the provided name and list of hosts IDs

        Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write

        :param group_in: Data required to create a record for a group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_create_group_serialize(
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "201": "GroupOutWithHostCount",
            "400": None,
            "403": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_create_group_serialize(
        self,
        group_in,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if group_in is not None:
            _body_params = group_in

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth", "BearerAuth"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/groups",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_group_delete_groups(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a list of groups

        Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_groups_serialize(
            group_id_list=group_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_delete_groups_with_http_info(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a list of groups

        Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_groups_serialize(
            group_id_list=group_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_delete_groups_without_preload_content(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a list of groups

        Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_groups_serialize(
            group_id_list=group_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_delete_groups_serialize(
        self,
        group_id_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "group_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if group_id_list is not None:
            _path_params["group_id_list"] = group_id_list
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/groups/{group_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_group_delete_hosts_from_different_groups(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a list of hosts from the groups they are in

        Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_hosts_from_different_groups_serialize(
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_delete_hosts_from_different_groups_with_http_info(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a list of hosts from the groups they are in

        Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_hosts_from_different_groups_serialize(
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_delete_hosts_from_different_groups_without_preload_content(
        self,
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a list of hosts from the groups they are in

        Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write

        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_delete_hosts_from_different_groups_serialize(
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_delete_hosts_from_different_groups_serialize(
        self,
        host_id_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/groups/hosts/{host_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_group_get_group_list(
        self,
        name: Annotated[StrictStr | None, Field(description="Filter by group name")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        group_type: Annotated[
            StrictStr | None, Field(description="The type of workspaces that should be returned.")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupQueryOutput:
        """Read the entire list of groups

        Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read

        :param name: Filter by group name
        :type name: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param group_type: The type of workspaces that should be returned.
        :type group_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_group_list_serialize(
            name=name,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            group_type=group_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_get_group_list_with_http_info(
        self,
        name: Annotated[StrictStr | None, Field(description="Filter by group name")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        group_type: Annotated[
            StrictStr | None, Field(description="The type of workspaces that should be returned.")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupQueryOutput]:
        """Read the entire list of groups

        Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read

        :param name: Filter by group name
        :type name: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param group_type: The type of workspaces that should be returned.
        :type group_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_group_list_serialize(
            name=name,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            group_type=group_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_get_group_list_without_preload_content(
        self,
        name: Annotated[StrictStr | None, Field(description="Filter by group name")] = None,
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        group_type: Annotated[
            StrictStr | None, Field(description="The type of workspaces that should be returned.")
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Read the entire list of groups

        Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read

        :param name: Filter by group name
        :type name: str
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param group_type: The type of workspaces that should be returned.
        :type group_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_group_list_serialize(
            name=name,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            group_type=group_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_get_group_list_serialize(
        self,
        name,
        per_page,
        page,
        order_by,
        order_how,
        group_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if name is not None:
            _query_params.append(("name", name))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        if group_type is not None:
            _query_params.append(("group_type", group_type))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/groups",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_group_get_groups_by_id(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupQueryOutput:
        """Find groups by their IDs

        Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_groups_by_id_serialize(
            group_id_list=group_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_get_groups_by_id_with_http_info(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupQueryOutput]:
        """Find groups by their IDs

        Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_groups_by_id_serialize(
            group_id_list=group_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_get_groups_by_id_without_preload_content(
        self,
        group_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of group IDs."),
        ],
        per_page: Annotated[
            Annotated[int, Field(le=100, strict=True, ge=1)] | None,
            Field(description="A number of items to return per page."),
        ] = None,
        page: Annotated[
            Annotated[int, Field(le=21474837, strict=True, ge=1)] | None,
            Field(description="A page number of the items to return."),
        ] = None,
        order_by: Annotated[StrictStr | None, Field(description="Ordering field name")] = None,
        order_how: Annotated[
            Annotated[str, Field(strict=True)] | None,
            Field(
                description="Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count"
            ),
        ] = None,
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find groups by their IDs

        Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read

        :param group_id_list: A comma-separated list of group IDs. (required)
        :type group_id_list: List[str]
        :param per_page: A number of items to return per page.
        :type per_page: int
        :param page: A page number of the items to return.
        :type page: int
        :param order_by: Ordering field name
        :type order_by: str
        :param order_how: Direction of the ordering (case-insensitive); defaults to ASC for name, and to DESC for host_count
        :type order_how: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_get_groups_by_id_serialize(
            group_id_list=group_id_list,
            per_page=per_page,
            page=page,
            order_by=order_by,
            order_how=order_how,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupQueryOutput",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_get_groups_by_id_serialize(
        self,
        group_id_list,
        per_page,
        page,
        order_by,
        order_how,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "group_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if group_id_list is not None:
            _path_params["group_id_list"] = group_id_list
        # process the query parameters
        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if page is not None:
            _query_params.append(("page", page))

        if order_by is not None:
            _query_params.append(("order_by", order_by))

        if order_how is not None:
            _query_params.append(("order_how", order_how))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/groups/{group_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_group_patch_group_by_id(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        group_in: Annotated[
            GroupIn,
            Field(
                description="A dictionary with new information with which to update the original group."
            ),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupOutWithHostCount:
        """Update group information

        Update group information, removing any existing host associations from the group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param group_in: A dictionary with new information with which to update the original group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_patch_group_by_id_serialize(
            group_id=group_id,
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_group_patch_group_by_id_with_http_info(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        group_in: Annotated[
            GroupIn,
            Field(
                description="A dictionary with new information with which to update the original group."
            ),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupOutWithHostCount]:
        """Update group information

        Update group information, removing any existing host associations from the group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param group_in: A dictionary with new information with which to update the original group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_patch_group_by_id_serialize(
            group_id=group_id,
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_group_patch_group_by_id_without_preload_content(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        group_in: Annotated[
            GroupIn,
            Field(
                description="A dictionary with new information with which to update the original group."
            ),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update group information

        Update group information, removing any existing host associations from the group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param group_in: A dictionary with new information with which to update the original group. (required)
        :type group_in: GroupIn
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_group_patch_group_by_id_serialize(
            group_id=group_id,
            group_in=group_in,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_group_patch_group_by_id_serialize(
        self,
        group_id,
        group_in,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {}

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if group_id is not None:
            _path_params["group_id"] = group_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if group_in is not None:
            _body_params = group_in

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/groups/{group_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_group_add_host_list_to_group(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        request_body: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="A list of hosts IDs to associate with the provided group."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupOutWithHostCount:
        """Add host IDs to the provided group

        Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param request_body: A list of hosts IDs to associate with the provided group. (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_add_host_list_to_group_serialize(
            group_id=group_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_group_add_host_list_to_group_with_http_info(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        request_body: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="A list of hosts IDs to associate with the provided group."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupOutWithHostCount]:
        """Add host IDs to the provided group

        Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param request_body: A list of hosts IDs to associate with the provided group. (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_add_host_list_to_group_serialize(
            group_id=group_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_group_add_host_list_to_group_without_preload_content(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        request_body: Annotated[
            list[Annotated[str, Field(strict=True)]] | None,
            Field(description="A list of hosts IDs to associate with the provided group."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add host IDs to the provided group

        Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param request_body: A list of hosts IDs to associate with the provided group. (required)
        :type request_body: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_add_host_list_to_group_serialize(
            group_id=group_id,
            request_body=request_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "200": "GroupOutWithHostCount",
            "400": None,
            "404": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_group_add_host_list_to_group_serialize(
        self,
        group_id,
        request_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "request_body": "",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if group_id is not None:
            _path_params["group_id"] = group_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if request_body is not None:
            _body_params = request_body

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type([
                "application/json"
            ])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/groups/{group_id}/hosts",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def api_host_group_delete_hosts_from_group(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete one or more hosts from a group

        Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_delete_hosts_from_group_serialize(
            group_id=group_id,
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def api_host_group_delete_hosts_from_group_with_http_info(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete one or more hosts from a group

        Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_delete_hosts_from_group_serialize(
            group_id=group_id,
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def api_host_group_delete_hosts_from_group_without_preload_content(
        self,
        group_id: Annotated[str, Field(strict=True, description="Group ID.")],
        host_id_list: Annotated[
            list[Annotated[str, Field(strict=True)]],
            Field(description="A comma-separated list of host IDs."),
        ],
        _request_timeout: None
        | Annotated[StrictFloat, Field(gt=0)]
        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete one or more hosts from a group

        Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write

        :param group_id: Group ID. (required)
        :type group_id: str
        :param host_id_list: A comma-separated list of host IDs. (required)
        :type host_id_list: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """

        _param = self._api_host_group_delete_hosts_from_group_serialize(
            group_id=group_id,
            host_id_list=host_id_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: dict[str, str | None] = {
            "204": None,
            "400": None,
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _api_host_group_delete_hosts_from_group_serialize(
        self,
        group_id,
        host_id_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "host_id_list": "csv",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[str, str | bytes] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if group_id is not None:
            _path_params["group_id"] = group_id
        if host_id_list is not None:
            _path_params["host_id_list"] = host_id_list
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: list[str] = ["ApiKeyAuth"]

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/groups/{group_id}/hosts/{host_id_list}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
